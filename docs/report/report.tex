\documentclass{../llncs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% package sillabazione italiana e uso lettere accentate
%\usepackage[latin1]{inputenc}
\usepackage[utf8]{inputenc}
%\usepackage[english]{babel}
%\usepackage[italian]{babel}
\usepackage[english,italian]{babel} % documento in italiano con alcune parti in inglese
\usepackage[T1]{fontenc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Per singole parole o brevi frasi in lingua straniera è disponibile il comando
% \foreignlanguage{lingua}{testo}
% 
% Per porzioni di testo in lingua più consistenti è disponibile l’ambiente
% \begin{otherlanguage*}{lingua}
% ...
% \end{otherlanguage*}

% per gli elenchi
\usepackage{enumitem}

% per la bibliografia
\usepackage[
	autostyle,italian=guillemets
	% ... altre opzioni
]{csquotes}

\usepackage[
	% ... opzioni
	backend=biber
]{biblatex}

%\addbibresource{../bibliografia.bib}

\defbibfilter{papers}{
  type=article or
  type=inproceedings
}

\defbibheading{principali}{\subsection*{Bibliografia essenziale}}
\defbibheading{web}{\subsection*{Fonti e materiali on-line}}
\defbibheading{integrative}{\subsection*{Letture di approfondimento}}

% ambiente per le citazioni, in alternativa a quelli standard (quote e quotation)
\usepackage{quoting}
\quotingsetup{font=small}

% per usare \caption* per didascalie senza intestazione e numero
\usepackage{caption}

% https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\newcommand{\xsource}[1]{\scriptsize{\textbf{Source:} {#1}}}
\newcommand{\source}[1]{\caption*{\xsource{#1}} }
\newcommand{\rsource}[1]{\vspace{-10pt} \caption*{\hfill \xsource{#1}} }
\newcommand{\tsource}[1]{\vspace{-10pt} \caption*{\xsource{#1}} }

% per le unità di misura
\usepackage[output-decimal-marker={,}]{siunitx}

\usepackage{xcolor}
\definecolor{darkgreen}{HTML}{007700}

% per il valore assoluto
\usepackage{mathtools}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}

\lstset{
	basicstyle=\small\ttfamily,
	columns=fullflexible,
	keywordstyle=\color{violet}\bfseries,
	commentstyle=\color{darkgreen},
	breaklines=true,	 			% sets automatic line breaking
	captionpos=b,					% sets the caption-position to bottom
	stringstyle=\color{blue},     	% string literal style
	showstringspaces=false, 		% no special string spaces
	caption={\lstname},
	% title=\lstname,               % show the filename of files included with \lstinputlisting;
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	frame=shadowbox
	% , float=*
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{url}
\usepackage{xspace}
\usepackage{color}
\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{../manifest}

\makeatother

% https://en.wikibooks.org/wiki/LaTeX/Hyperlinks
% LaTeXimpaziente: "Il pacchetto hyperref, che di regola va caricato per ultimo, crea i collegamenti ipertestualivall’interno del documento, rendendo cliccabili i riferimenti incrociati"
\usepackage{hyperref}

%%%%%%%
 \newif\ifpdf
 \ifx\pdfoutput\undefined
 \pdffalse % we are not running PDFLaTeX
 \else
 \pdfoutput=1 % we are running PDFLaTeX
 \pdftrue
 \fi
%%%%%%%
 \ifpdf
 \usepackage[pdftex]{graphicx}
 \else
 \usepackage{graphicx}
 \fi
%%%%%%%%%%%%%%%
 \ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg, .tif}
 \else
 \DeclareGraphicsExtensions{.eps, .jpg}
 \fi
%%%%%%%%%%%%%%%

\newcommand{\java}{\textsf{Java}\xspace}
\newcommand{\android}{\texttt{Android}}
\newcommand{\dsl}{\texttt{DSL}}
\newcommand{\jazz}{\texttt{Jazz}}
\newcommand{\rtc}{\texttt{RTC}}
\newcommand{\ide}{\texttt{Contact-ide}}
\newcommand{\xtext}{\texttt{XText}}
\newcommand{\xpand}{\texttt{Xpand}}
\newcommand{\xtend}{\texttt{Xtend}}
\newcommand{\pojo}{\texttt{POJO}}
\newcommand{\junit}{\texttt{JUnit}}

\newcommand{\action}[1]{\texttt{#1}\xspace}
% \newcommand{\codescript}[1]{{\scriptsize{\texttt{#1}}}\xspace}
\newcommand{\codescript}[1]{{\mbox{\small{\texttt{#1}}}}\xspace}
\newcommand{\code}[1]{{\color{blue}\small{\texttt{#1}}}}
\newcommand{\fname}[1]{{\small{\color{magenta}\texttt{#1}}}}
\newcommand{\node}{\textsf{NodeJs}}
\newcommand{\qa}{\textsf{\textit{QActor}}\xspace}

% Cross-referencing
\newcommand{\labelsec}[1]{\label{sec:#1}}
\newcommand{\xs}[1]{\sectionname~\ref{sec:#1}}
\newcommand{\xsp}[1]{\sectionname~\ref{sec:#1} \onpagename~\pageref{sec:#1}}
\newcommand{\labelssec}[1]{\label{ssec:#1}}
\newcommand{\xss}[1]{\subsectionname~\ref{ssec:#1}}
\newcommand{\xssp}[1]{\subsectionname~\ref{ssec:#1} \onpagename~\pageref{ssec:#1}}
\newcommand{\labelsssec}[1]{\label{sssec:#1}}
\newcommand{\xsss}[1]{\subsectionname~\ref{sssec:#1}}
\newcommand{\xsssp}[1]{\subsectionname~\ref{sssec:#1} \onpagename~\pageref{sssec:#1}}
\newcommand{\labelfig}[1]{\label{fig:#1}}
\newcommand{\xf}[1]{\figurename~\ref{fig:#1}}
\newcommand{\xfp}[1]{\figurename~\ref{fig:#1} \onpagename~\pageref{fig:#1}}
\newcommand{\labeltab}[1]{\label{tab:#1}}
\newcommand{\xt}[1]{\tablename~\ref{tab:#1}}
\newcommand{\xtp}[1]{\tablename~\ref{tab:#1} \onpagename~\pageref{tab:#1}}
% Category Names
\newcommand{\sectionname}{Section}
\newcommand{\subsectionname}{Subsection}
\newcommand{\sectionsname}{Sections}
\newcommand{\subsectionsname}{Subsections}
\newcommand{\secname}{\sectionname}
\newcommand{\ssecname}{\subsectionname}
\newcommand{\secsname}{\sectionsname}
\newcommand{\ssecsname}{\subsectionsname}
\newcommand{\onpagename}{on page}

% What’s wrong with \bf, \it, etc.? --> https://texfaq.org/FAQ-2letterfontcmd
% \newcommand{\todo}[1]{\bf{TODO:}\emph{#1}}
\newcommand{\todo}[1]{\vspace{8px} \textbf{TODO:} \emph{#1}\\ \vspace{8px}}
\newcommand{\eng}[1]{\foreignlanguage{english}{\emph{#1}}}
\newcommand{\engl}[1]{\emph{#1}}
% \textit{ }

\newcommand{\xauth}{Filippo Frabetti}
\newcommand{\xemail}{filippo.frabetti@studio.unibo.it}
\newcommand{\xunibo}{Dipartimento di Informatica - Scienza e Ingegneria (DISI)\\Università di Bologna} % Alma Mater Studiorum
\newcommand{\xcourse}{Fondamenti di Intelligenza Artificiale M -- A.A. 2018/19}
\newcommand{\xtitle}{Attività progettuale su Genetic Programming}


% table of contents fino a subsubsections
\setcounter{tocdepth}{3}

% Mette i numeri di pagina nel piede, lasciando vuota la testatina
\pagestyle{plain}

% Tables: the height of each row is set to 1.5 relative to its default height
\renewcommand{\arraystretch}{1.5}
% The space between the text and the left/right border of its containing cell
\setlength{\tabcolsep}{6pt}

% %%%%%%%%%%%%%%%% BEGIN DOCUMENT %%%%%%%%%%%%%%%%
\begin{document}

\title{\xtitle}

\author{\xauth}

\institute{
  \xunibo
%  \email{\xemail}
}

% no titolo+autore nell'indice
{\def\addcontentsline#1#2#3{}\maketitle}
%\maketitle

\vspace{16px}
\begin{center}
\textbf{\xcourse}
\end{center}

% evita le righe eccessivamente lunghe aumentando la spaziatura tra le parole
% Il comando \fussy ripristina le impostazioni predefinite 
\sloppy

% indice sezioni
\tableofcontents
\newpage

%===========================================================================
\section{Introduzione}
\labelsec{overview}

Lo scopo di questa attività progettuale è quello di approfondire le tematiche relative all'utilizzo di tecniche di Genetic Programming per evolvere, in modo automatico, euristiche che possano guidare la ricerca nello spazio degli stati di un gioco a conoscenza completa, nella fattispecie il cosiddetto Gioco del Mulino o Schiera (\textit{Nine Men's Morris}).\\

Una prima parte dell'attività è dedicata all'investigazione dell'algoritmo di GP in generale, partendo dall'analisi di un'implementazione funzionante di questi (\emph{TinyGP}) per poi costruire una propria implementazione in versione Object-Oriented, in linguaggio \java.

Particolarmente rilevante a tal fine è la possibilità di effettuare semplici test di comparazione tra le due versioni dell'algoritmo, così da avere una forma di conferma empirica della correttezza dell'implementazione creata, conferma che sarebbe altrimenti difficile da ottenere data l'elevata componente stocastica presente nei processi di GP.\\

La seconda parte riguarda invece l'applicazione dell'algoritmo al Gioco del Mulino, con l'obiettivo di evolvere euristiche significative non basate su alcuna conoscenza strategica umana sul dominio del problema, e quindi prive di eventuali bias cognitivi. In particolare, speriamo di ottenere formule che diano, con buona approssimazione, un'indicazione sulla bontà di una mossa/di un dato stato della scacchiera a partire da una serie di dati in ingresso sullo stato stesso.

L'idea di fondo non è tanto quella di sviluppare giocatori particolarmente competitivi e intelligenti, quanto quella di dedurre quali siano le variabili che maggiormente influenzano lo stato della partita a seconda di dove queste compaiono all'interno delle euristiche migliori trovate. In linea di massima infatti, più una variabile si trova vicina alla radice, maggiore sarà il suo peso sul risultato finale e quindi sulla valutazione dello stato della partita. Viceversa, le variabili più ``periferiche'' avranno, relativamente, un'importanza minore.

\section{TinyGP}
\labelsec{tinygp}

\emph{TinyGP} è l'implementazione dell'algoritmo di Programmazione Genetica fornita nell'appendice B di \footnote{\url{http://www.gp-field-guide.org.uk/}} e originariamente sviluppata nell'ambito dell'omonima competizione tenutasi all'interno della Genetic and Evolutionary Computation Conference (GECCO) del 2004.

Per quanto sia soltanto uno dei tanti sistemi di Genetic Programming disponibili in rete, il suo pregio risiede nell'estrema compattezza e semplicità del codice e nella facilità di utilizzo, prestandosi quindi come un buon punto di partenza per capire le meccaniche di base dell'algoritmo e per effettuare alcuni semplici esperimenti.\\

Per essere precisi, l'implementazione pubblicata è la versione in \java di una precedente scritta in C per motivi di performance e di dimensioni dell'eseguibile risultante. Sebbene quindi formalmente si tratti di un programma \java, lo stile utilizzato è puramente procedurale e \emph{C-like}.

\subsection{Caratteristiche generali}
\labelssec{TinyGP_mainFeatures}

\begin{itemize}
\item Simboli terminali: un numero configurabile di variabili ($x_1$, \ldots, $x_n$) e di costanti casuali
\item Simboli di funzione: addizione, sottrazione, moltiplicazione e divisione protetta\footnote{Per evitare fallimenti a runtime, la divisione per zero viene intercettata prima della sua esecuzione (\emph{evaluation safety}).} (tutte funzioni binarie, a due argomenti)
\item Per la costituzione della popolazione iniziale viene utilizzato il metodo \emph{grow} con profondità massima configurabile
\item Il sistema è \emph{steady state}: il numero di individui per generazione è configurabile, ma costante; una generazione è considerata conclusa solo dopo che sono state effettuate tante operazioni genetiche quanti sono gli individui
\item La selezione avviene tramite \emph{tournament selection}, mentre tornei ``negativi'' vengono utilizzati per la scelta degli individui da sostituire
\item Operatori: \emph{subtree crossover} (con probabilità uniforme di selezionare un qualsiasi nodo) e \emph{point mutation}
\item Terminazione: ad ogni generazione, se la fitness del programma migliore è inferiore a una certa soglia ($10^{-5}$), l'algoritmo termina con successo, altrimenti termina con fallimento una volta raggiunto il numero massimo di generazioni impostato
\end{itemize}

\subsubsection{Fitness}
La fitness è data dall'opposto (``meno'') della somma delle differenze, in valore assoluto, tra l'output attuale e quello desiderato per ogni \emph{fitness case}.
I \emph{fitness case} vengono letti da file, uno per riga, e sono costituiti dall'assegnamento di un valore per ogni variabile e di un valore atteso per il risultato.

L'algoritmo di GP mira a massimizzare la funzione di fitness, ovvero a minimizzare l'errore totale tra i risultati attesi e quelli attuali.

\subsection{Parametri di configurazione e interfacce di utilizzo}
\labelssec{TinyGP_parameters}

Da linea di comando è possibile passare un \emph{seed} opzionale per il random number generator (se assente viene generato dal sistema) e il nome del file che contiene alcuni parametri dell'algoritmo e i \emph{fitness case}; se omesso viene ricercato un file chiamato ``problem.dat'' nel direttorio corrente.\\

\noindent La struttura del file di input è la seguente:
\begin{lstlisting}[caption={Struttura del file di input}]
NVAR NRAND MINRAND MAXRAND NFITCASES
V11 V12 ... V1n TARGET1
...
Vk1 Vk2 ... Vkn TARGETk
\end{lstlisting}
dove:
\begin{itemize}
\setlength\itemsep{0.1em}
\item[-] \texttt{NVAR} è il numero di variabili ($=n$, $x_1$ \ldots $x_n$)
\item[-] \texttt{NRAND} è il numero di costanti casuali da inserire come simboli terminali
\item[-] \texttt{MINRAND} e \texttt{MAXRAND} determinano il range da utilizzare per la generazione delle costanti casuali (\texttt{double})
\item[-] \texttt{NFITCASES} è il numero di \emph{fitness case} e di righe in aggiunta alla prima ($=k$)
\item[-] \texttt{Vij} è il valore da assegnare alla variabile $x_j$ ($j = 1, \ldots, n$) alla valutazione del \emph{fitness case} $i$ ($i = 1, \ldots, k$)
\item[-] \texttt{TARGETi} è il risultato atteso per il \emph{fitness case} $i$
\end{itemize}

\noindent Parametri di configurazione staticamente definiti all'interno del codice:
\begin{itemize}
\setlength\itemsep{0.1em}
\item \texttt{MAX{\_}LEN}: dimensione massima che un singolo programma può avere
\item \texttt{POPSIZE}: numero di individui in ogni generazione
\item \texttt{DEPTH}: profondità massima degli individui nella popolazione iniziale
\item \texttt{GENERATIONS}: numero massimo di generazioni
\item \texttt{CROSSOVER{\_}PROB}: probabilità di utilizzare l'operatore crossover, in alternativa alla mutazione
\item \texttt{PMUT{\_}PER{\_}NODE}: nel caso di mutazione, la probabilità che un singolo nodo venga mutato
\item \texttt{TSIZE}: numero di individui selezionati per ogni torneo
\end{itemize}

\noindent Ad ogni generazione vengono calcolate e stampate le seguenti statistiche:
\begin{itemize}
\setlength\itemsep{0.1em}
\item Numero della generazione corrente
\item Fitness e dimensione medie della popolazione
\item Individuo migliore e la sua fitness
\end{itemize}

\subsection{Dettagli dell'implementazione}
\subsubsection{Rappresentazione interna}
La rappresentazione interna utilizzata per gli individui/programmi non è altro che la linearizzazione della classica struttura ad albero tramite la notazione prefissa, dove ogni operatore è semplicemente seguito dai suoi operandi.
Ad esempio, la seguente espressione in notazione infissa:
\[
(3+4)*5
\]
può essere rappresentata senza ambiguità in notazione prefissa come:
\[
* + 3\:4\:5
\]
Mentre sotto forma di albero si avrebbe un nodo radice (*) che ha come figlio sinistro la somma di 3 e 4 (ovvero un sotto-albero $+$, con figli 3 e 4) e come figlio destro 5.\\

Grazie alla notazione prefissa è possibile fare a meno di parentesi e di regole di priorità degli operatori, ovvero non è nemmeno necessario mantenere, come sarebbe necessario fare nel caso di una rappresentazione ad albero, la distinzione dei diversi livelli di priorità. L'espressione $2+3*5$ infatti, pur non necessitando di parentesi, sotto forma di albero dovrebbe conservare in qualche modo la semantica di valutazione \textit{``prima moltiplicazioni e divisioni''}, generando un albero a due livelli ben diverso da quello prodotto da $(2+3)*5$.\\

La notazione prefissa ha quindi il vantaggio di poter mantenere in memoria pure sequenze di simboli, terminali o di funzione, riducendo ogni individuo ad un semplice array. Come vedremo, la scelta è di semplificare il più possibile le strutture dati di supporto, retaggio della versione in C, facendo uso di array di byte.

Naturalmente, appositi meccanismi vengono messi in atto per effettuare le operazioni di crossover e di mutazione sugli array, così come la generazione di individui (\emph{grow}) e la loro valutazione come espressioni.

\subsubsection{Simboli terminali e di funzione}
Come precedentemente accennato, la codifica utilizzata prevede di memorizzare ogni individuo/espressione come un array di byte (\texttt{char[]}). Per fare ciò occorre mappare tutti i simboli, terminali e di funzione, in un singolo byte ciascuno, per un totale di 256 possibili simboli.

L'idea è quella di utilizzare gli indici da 0 a 255 al posto dei \emph{valori} (nel caso delle costanti numeriche) e dei \emph{simboli} (nel caso delle variabili e degli operatori di funzione), così da effettuare tutte le operazioni genetiche sugli indici e ricorrendo ai valori riferiti quasi esclusivamente al momento della valutazione della fitness.\\

Il semplice individuo dell'esempio precedente, $* + 3\:4\:5$, in questa notazione basata su indici potrebbe quindi diventare qualcosa del tipo\footnote{043, 044 e 045 sono stati scritti con lo 0 davanti unicamente per evidenziare il fatto che non si tratta dei numeri 43, 44 e 45, ma di \emph{indici} che identificano dei valori numerici (in questo caso 3, 4 e 5). In \java la differenza è ancora più netta, in quanto questi ultimi sarebbero valori a virgola mobile a doppia precisione (\texttt{double}).}:
\[
112\;110\;043\;044\;045
\]
L'implementazione impiega, per scelta arbitraria, solamente i primi 114 indici sui 256 teoricamente disponibili. Il numero massimo di variabili e di costanti numeriche -- ovvero il numero massimo di simboli terminali -- è quindi vincolato a 110 ($=114-4$, dove 4 sono le funzioni presenti)\footnote{In effetti, per una probabile svista, il massimo numero ammesso risulta essere 109.}.\\

All'esecuzione del programma vengono generati in ogni caso, indipendentemente dal numero di variabili e di costanti impostato, 110 valori casuali nel range specificato da \texttt{MINRAND} e \texttt{MAXRAND}, per essere successivamente puntati dai relativi indici.

Da notare come di questi 110, solamente quelli con indice compreso tra \texttt{NVAR} e \texttt{NVAR+NRAND-1} saranno realmente utilizzati.

\subsubsection{Popolazione di partenza}
La prima generazione viene costruita tramite il metodo \emph{grow}, con una probabilità del 50\% di scegliere un terminale per ogni nuovo simbolo prima del raggiungimento della profondità massima impostata (\texttt{DEPTH}).

Nel raro caso che un individuo superi complessivamente la dimensione limite (\texttt{MAX{\_}LEN}) in termini di numero di nodi/simboli, questo viene scartato e ri-generato da capo.

\subsubsection{Valutazione della fitness}
Per quanto riguarda la fitness, per ogni \emph{fitness case} vengono copiati i valori -- letti da file -- da assegnare alle variabili nelle prime \texttt{NVAR} posizioni della tabella di conversione tra indici e costanti generate casualmente. In questo modo, all'esecuzione del programma il valutatore può ``dimenticarsi'' di quali indici rappresentino delle variabili e quali delle costanti, limitandosi a dover distinguere i soli indici che puntano a simboli di funzione.\\

Per l'esecuzione di una funzione vengono ricorsivamente prelevati dell'array, ed eventualmente calcolati, i suoi operandi.

Una menzione particolare merita di essere fatta per la divisione protetta ($/_p$), implementata nel seguente modo:
\[
num \: /_p \: den =
\begin{cases}
num & \text{se $\abs{den}\le0.001$} \\
num/den & \text{altrimenti}
\end{cases}
\]

La fitness viene immediatamente valutata per tutti i nuovi individui e memorizzata per impieghi futuri, in particolare per essere usata per effettuare le selezioni ``positive'' e ``negative'', per le statistiche relative ad ogni generazione e per la valutazione della condizione di terminazione.

\subsubsection{Ricombinazione e sostituzione}
Come menzionato nella sezione precedente, per mantenere le generazioni di dimensione costante, ogni nuovo individuo viene immediatamente inserito al posto di un altro già presente, selezionato tramite un torneo negativo. Non vi è dunque una netta separazione tra generazioni successive, nel senso che un individuo appena inserito all'interno della popolazione potrebbe essere scelto indistintamente come `genitore' di un altro individuo appartenente alla stessa generazione.

L'unica discriminante tra un individuo creato in una generazione piuttosto che in un'altra è quindi il solo conteggio delle operazioni genetiche effettuate, conteggio che si resetta ogni volta che si raggiunge il numero impostato come dimensione della popolazione.\\

La scelta, che premia la bassa occupazione di memoria e l'inserimento immediato di nuovi individui (potenzialmente migliori dei genitori), rende tuttavia il sistema più incline a soffrire di una possibile perdita di varietà dovuta proprio alle sostituzioni: una volta scelto un individuo tramite torneo negativo, infatti, questo viene perso per sempre anche se solo localmente peggiore di altri.

\section{Old}
Partendo dall'implementazione fornita in \footnote{\url{http://www.gp-field-guide.org.uk/}}, \emph{TinyGP}, un primo test consiste nell'eseguire il programma per approssimare, tramite Genetic Programming, la funzione seno in un certo intervallo (\texttt{[0, 6.2]}). Tuttavia, a differenza di quanto fatto in \footnote{\url{https://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/B4CompilingandRunningTinyGP.html}}, si sceglie di esplicitare un \emph{seed} come primo argomento da riga di comando (nella fattispecie uguale a 1), così da consentire l'esatta replicazione dell'esperimento.

Data la struttura del progetto, occorre collocarsi in \texttt{\{USER\_SPECIFIC\}/ProjectWork\_GP/NotSoTinyGP/bin} ed utilizzare il comando:
\begin{lstlisting}[caption={Esecuzione di TinyGP da riga di comando}]
java tinygp.tiny_gp 1 ..\resources\sin\sin-data.txt > ..\tinygp_seed1.out
\end{lstlisting}
Per praticità di consultazione, tutto ciò che viene stampato in output viene rediretto in un apposito file di testo.

\section{NotSoTinyGP}
L'implementazione \emph{NotSoTinyGP} mira a re-interpretare le logiche dell'algoritmo di Genetic Programming viste in \emph{TinyGP} in chiave Object-Oriented, spostando il focus non tanto sulla compattezza del codice e la sua efficienza a runtime, quanto sulla modularità e sull'estensibilità.

Si considerino ad esempio i casi in cui si volesse -- ed in parte è stato fatto -- aggiungere altri meccanismi per la generazione della popolazione iniziale, come i metodi \emph{full} e \emph{ramped half-and-half}, altri operatori genetici, altre funzioni oltre alle quattro operazioni elementari, eccetera.\\

Mentre da un lato si è cercato di mantenere per certi versi una forma di compatibilità con \emph{TinyGP}, specialmente per quanto riguarda l'aspetto delle interfacce di utilizzo, dall'altro si è scelto di approfittare della scrittura di questa nuova implementazione per sperimentare varianti relative ad alcune scelte progettuali, così che la messa a confronto delle due versioni non si limiti ad una semplice questione di efficienza e di variazioni stocastiche.

In ogni caso, le differenze tra le due implementazioni verranno riprese più nel dettaglio in seguito, in una sezione dedicata.

\subsection{Caratteristiche generali}
Si elencano solo quelle che si discostano da quanto dichiarato in \xss{TinyGP_mainFeatures} per \emph{TinyGP}.
\begin{itemize}
\item Simboli terminali e di funzione: ottenibili tramite un'apposita \texttt{NodeFactory}, pertanto facilmente configurabili
\item Per la costituzione della popolazione iniziale possono essere utilizzati il seguenti metodi: \emph{grow}, \emph{full}, \emph{ramped half-and-half} o versioni `ibride' di questi, ad esempio con una proporzione configurabile di \emph{grow} e \emph{full}
%\item Il sistema è \emph{steady state}: il numero di individui per generazione è configurabile, ma costante; una generazione è considerata conclusa solo dopo che sono state effettuate tante operazioni genetiche quanti sono gli individui
\item La selezione avviene tramite \emph{tournament selection}. Non vengono invece utilizzati tornei ``negativi'' per la scelta degli individui da sostituire
\item Operatori: \emph{subtree crossover} (con probabilità configurabile di selezionare un simbolo di funzione), \emph{point mutation}, \emph{subtree mutation} e riproduzione
%\item Terminazione: ad ogni generazione, se la fitness del programma migliore è inferiore a una certa soglia ($10^{-5}$), l'algoritmo termina con successo, altrimenti termina con fallimento una volta raggiunto il numero massimo di generazioni impostato
\end{itemize}

\subsection{Parametri di configurazione e interfacce di utilizzo}
Per quanto riguarda i parametri e le modalità di utilizzo, la scelta è di garantire, per quanto possibile, uniformità con quanto avviene in \emph{TinyGP}, mantenendo gli stessi argomenti da linea di comando e lo stesso formato per il file di configurazione contenente i \emph{fitness case}.

Viene considerato tuttavia inadeguato l'impiego di parametri definiti come campi statici, in quanto renderebbero necessaria una nuova compilazione ad ogni modifica nella configurazione, violando inoltre il principio di design secondo cui \emph{NotSoTinyGP} mira ad essere modulare e facilmente estensibile.\\

A questo proposito viene introdotto un ulteriore argomento opzionale da riga di comando: il nome di un file \texttt{Properties} consultabile a runtime e contenente tutti i parametri necessari.

\noindent Al momento è possibile invocare \emph{TinyGP} con i seguenti argomenti:
\begin{itemize}
\item file di configurazione
\item file di configurazione e seed
\end{itemize}
a questi viene aggiunto:
\begin{itemize}
\item file di configurazione, seed e file \texttt{Properties}
\end{itemize}

Inoltre, nei due casi precedenti, viene comunque ricercato nel direttorio corrente un file che termini con \texttt{.properties}: il primo trovato viene caricato nelle \texttt{Properties}, mentre eventuali altri saranno ignorati. Se anche questa ricerca dovesse risultare infruttuosa, allora ogni componente dell'algoritmo deve essere in grado di funzionare ugualmente ricorrendo a valori di default.

\subsection{Dettagli dell'implementazione}
\subsubsection{Rappresentazione interna}
La rappresentazione scelta per gli individui/programmi è quella tradizionale, ad albero, basata su una semplice gerarchia composta da \texttt{TerminalNode} (nodi terminali o foglie) e da \texttt{FunctionNode} (nodi intermedi o di funzione), entrambi sottoclassi di \texttt{Node}.

I riferimenti padre-figlio sono bidirezionali e la consistenza di tali collegamenti viene garantita dai relativi costruttori e metodi setter.

\subsubsection{Simboli terminali e di funzione}
Come precedentemente affermato, la generazione dei nodi viene affidata ad una factory, il cui compito è in sostanza quello di gestire gli insiemi dei simboli terminali e di funzione. %Le funzioni scelte sono, per semplicità, le stesse utilizzate da \emph{TinyGP}, ovvero le quattro operazioni elementari, e tra i terminali vi possono essere un numero configurabile di variabili.

Resta da definire è come garantire variabilità all'interno del \emph{terminal set} in termini di costanti numeriche. In questo caso, per differenziarsi dalla scelta fatta in \emph{TinyGP}, si è deciso di ricorrere ad una \emph{ephemeral random constant}, ovvero un simbolo-placeholder che, non appena selezionato, genera una nuova costante casuale (nell'intervallo presente nel file di input descritto in \xss{TinyGP_parameters}).\\

L'utilizzo di una \emph{ephemeral random constant} apre alcuni interrogativi su come gestire la cardinalità dell'insieme dei simboli terminali\footnote{Questa, insieme alla cardinalità dei simboli di funzione, può essere impiegata ad esempio nel metodo \emph{grow} per la generazione casuale di simboli prelevati dall'unione dei due insiemi.} e come la probabilità di scegliere, tra i terminali stessi, una variabile piuttosto che una costante, essendoci appunto \emph{un solo} simbolo corrispondente a costanti numeriche.

Entrambe le questioni sono state risolte considerando la compatibilità con le interfacce utilizzate da \emph{TinyGP}: poiché abbiamo a disposizione un parametro, \texttt{NRAND}, per indicare il numero di costanti casuali (e due per il loro range), questo viene utilizzato sia per stabilire la cardinalità dell'insieme, sommato al numero di variabili, sia per determinare la probabilità di scegliere una variabile ($\frac{nvar}{nvar+nrand}$). In questo secondo caso, se dovesse essere selezionata una costante numerica, questa viene generata casualmente ``al volo'' su richiesta; in altre parole, il sistema si comporta come se avesse a disposizione un insieme composto da \texttt{NRAND} \emph{ephemeral random constant}.

\subsubsection{Popolazione di partenza}
Per garantire una maggiore varietà nella popolazione iniziale, tra i diversi metodi disponibili, per i test viene utilizzato \emph{ramped half-and-half}, dove il 50\% degli individui vengono generati con \emph{full} e i restanti con \emph{grow}, in entrambi i casi sfruttando un range di profondità massime.\\

Una nota addizionale riguarda il metodo \emph{grow}: fissata una profondità limite, alla selezione di ogni nodo prima dell'ultimo livello (dove sono previsti solo nodi terminali) vi è una certa probabilità di scegliere una funzione piuttosto che un terminale. Come prima approssimazione si potrebbe pensare di determinare questa probabilità in base alla cardinalità relativa dei due insiemi, tuttavia ciò risulterebbe facilmente sbilanciato in molte situazioni reali in cui il numero di simboli terminali sovrasta quello delle funzioni.

Per lasciare aperte le porte a qualsiasi scenario di utilizzo, la scelta di come gestire la generazione di un nodo casuale viene delegata alle varie implementazioni di \texttt{NodeFactory}, senza che nulla di predefinito venga cablato all'interno dell'algoritmo \emph{grow}.

\subsection{Toy example: bilanciamento di pari e dispari}
TODO

\section{Confronto tra implementazioni}
Al di là delle differenze puramente implementative, come la scelta della rappresentazione interna da utilizzare per gli individui, quello che risulta più significativo sono le differenze nell'algoritmo, ovvero le ragioni per le quali dovrei, sperabilmente, aspettarmi risultati diversi dall'esecuzione delle due versioni sul medesimo problema (a prescindere da ovvie variazioni stocastiche).\\

Dopo aver riassunto brevemente quelle che sono le differenze più significative dal punto di vista concettuale, le implementazioni verranno testate su due semplici problemi di regressione: tentare di approssimare una funzione polinomiale e una periodica (la funzione seno) in un dato intervallo; questo secondo esempio viene ripreso in quanto si tratta di quello proposto in \footnote{\url{https://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/B4CompilingandRunningTinyGP.html}} per \emph{TinyGP}.

\subsection{Differenze concettuali}

\begin{table}
\begin{tabular}{l | p{3.7cm} | p{4.3cm}}
\textbf{Caratteristica} & \textbf{TinyGP} & \textbf{NotSoTinyGP} \\ \hline
Popolazione iniziale & \emph{grow} ($P_{term}=50\%$) & \emph{ramped half-and-half} (50/50 \emph{full}/\emph{grow}, $P_{term}=50\%$) \\ \hline
Costanti numeriche & set statico & \emph{ephemeral random constant} \\ \hline
Tornei negativi & sì, sostituzione immediata & no, generazioni distinte \\ \hline
Operatori & \emph{subtree crossover}, \emph{point mutation} & anche \emph{subtree mutation} e riproduzione \\
\end{tabular}
\end{table}

%\begin{itemize}
%\item Generazione della popolazione iniziale: \emph{grow} con probabilità 50\% di selezionare simboli terminali; \emph{ramped half-and-half} con parametri configurabili (di fatto 50\%-50\% \emph{full}/\emph{grow} e 50\% di terminazione prima della profondità massima per \emph{grow})
%\item Costanti numeriche: definite staticamente ``una-tantum'' o generate su richiesta tramite \emph{ephemeral random constant}
%\item Sostituzione immediata degli individui nella popolazione; netta separazione tra generazioni
%\item Operatori: impiego di operatori diversi, a seconda di quelli disponibili nei due casi
%\end{itemize}

\subsubsection{Generazione della popolazione iniziale}
Gli individui della generazione 0 sono solitamente di scarso interesse `pratico', ovvero come candidate soluzioni al problema, prima ancora di averne valutato la fitness: in primo luogo perché si tratta pur sempre di individui totalmente casuali, non derivanti da alcun processo di selezione, e in secondo luogo poiché di una dimensione troppo ridotta per poter sperare di approssimare con sufficiente precisione una `buona' soluzione.

Ciò che è rilevante è invece la varietà della popolazione iniziale (e, in effetti, anche di quelle successive), poiché ciò garantisce di esplorare porzioni diverse dello spazio delle soluzioni, contrastando la tendenza a focalizzarsi su regioni localmente ottime tipica degli algoritmi di ricerca \emph{greedy}.\\

Sebbene da un lato i metodi utilizzati in \emph{NotSoTinyGP} garantiscano una maggiore varietà nella popolazione iniziale, questa stessa varietà può essere facilmente `recuperata' dopo poche generazioni a partire da una popolazione più omogenea, portando difficilmente a differenze significative tra i risultati ottenibili dalle due implementazioni.

La varietà presente negli individui della popolazione iniziale potrebbe diventare rilevante in quei particolari casi in cui si è interessati a poche generazioni -- magari perché estremamente costose -- quindi si vuole evitare di pagare il prezzo di aspettare le ricombinazioni delle prime iterazioni.

\subsubsection{Utilizzo di costanti numeriche}
La scelta di generare una volta per tutte le costanti numeriche che tutti i programmi andranno ad utilizzare è, in larga parte, giustificabile per motivi di efficienza e, se vogliamo, di comodo, in quanto si pone un chiaro significato alla cardinalità dell'insieme dei simboli terminali.

La conseguente minore varietà di costanti ad uso dei vari individui viene in parte appianata dalla possibilità di eseguire l'algoritmo di GP più e più volte, per poi tenere il risultato migliore.\\

Un aspetto interessante da non trascurare è come, avendo un numero limitato di costanti numeriche a disposizione, risulti `più facile' effettuare semplificazioni e ricondursi a casi semplici anche con un numero medio-alto di nodi.

Si pensi ad esempio alla funzione $2x+1$: questa potrebbe essere perfettamente rappresentata da un individuo a 2 livelli ($+\:*\:2\:x\:1$ in notazione prefissa), mentre per un individuo di profondità 7 la cosa non sarebbe affatto facile. Tuttavia, con le dovute semplificazioni di termini opposti, al momento della valutazione si potrebbe arrivare ad ottenere un'espressione equivalente anche \emph{esattamente uguale} a $2x+1$.

\subsubsection{Selezione e sostituzione}
In entrambe le implementazioni il numero di individui per generazione è costante, tuttavia in \emph{NotSoTinyGP} non vengono effettuati tornei negativi per la sostituzione degli individui. Questo perché, per scelta, ogni generazione è rigidamente separata dalla precedente e dalla successiva, con la conseguenza che ogni individuo appartenente alla generazione $i$ può derivare unicamente da un'operazione genetica effettuata su uno o più individui della generazione $(i-1)$.\\

I tornei negativi aumentano la velocità di sostituzione degli individui `peggiori', da un lato con l'ovvio effetto benefico di velocizzare la ricerca tra quelli invece più performanti, dall'altro riducendo la varietà presente all'interno della popolazione: avere solo individui simili tra loro, infatti, è tutt'altro che desiderabile poiché equivale a focalizzarsi su un'unica zona dello spazio delle soluzioni. %(riducendo, di fatto, l'intero procedimento ad una pura \emph{greedy search}).

Da notare come in ambedue le implementazioni vi sia una certa probabilità che un individuo ``sparisca'' senza lasciare alcuna progenie, se non dovesse vincere alcun torneo di selezione, mentre altri, quelli che dimostrano localmente di essere \emph{the fittest}, daranno vita a più nuovi individui.

\subsubsection{Operatori}
Anche in questo caso il fatto di poter contare su un maggior numero di operatori genetici punta ad incrementare la varietà nella popolazione, e quindi a rendere più efficace il processo di ricerca.

In linea teorica, dietro ad ogni operatore risiederebbero motivazioni almeno in parte \emph{domain dependent}: in altre parole, se si utilizza il \emph{crossover} è perché si fa la (forte) assunzione che la combinazione di due individui ad alta fitness dia, con una certa probabilità, un individuo la cui fitness è maggiore rispetto a quella che si avrebbe, probabilisticamente parlando, dalla combinazione di genitori con fitness più scarsa.

Poiché tuttavia i problemi a cui vengono applicate tecniche di GP sono solitamente così complessi da non consentire di avere basi teoriche sufficienti da giustificare a priori l'utilizzo di un operatore piuttosto che un altro, quello che si fa è andare per tentativi: non conoscendo la migliore combinazione di operatori possibile, si cerca di utilizzarne vari, sperando che questi garantiscano una \emph{ragionevole} (ovvero non semplicemente casuale) ricerca nello spazio delle soluzioni.\\

Un operatore degno di menzione, impiegato in \emph{NotSoTinyGP} e presente in letteratura, è la riproduzione, ovvero la semplice `copia' di un individuo -- selezionato in base alla sua fitness -- da una generazione a quella successiva. L'utilizzo di questo operatore è a priorità inferiore rispetto al \emph{crossover} e alla mutazione, puntando a preservare, in un certo senso, buone combinazioni di geni invariate.

\subsection{Approssimazione di una funzione polinomiale}
\subsection{Approssimazione della funzione seno}
\subsection{Performance e tuning dei parametri}

\section{Applicazione al Gioco del Mulino}
\subsection{Iper-euristiche}
Il problema relativo al Gioco del Mulino per il quale viene chiamata in causa la Programmazione Genetica è quello di trovare buone euristiche, ottime o sub-ottime, tra tutte quelle possibili (potenzialmente infinite, in ogni caso tra un numero computazionalmente proibitivo). In questa sua applicazione, GP si colloca quindi come una forma di iper-euristica, ovvero come meccanismo di ricerca nello spazio delle euristiche.

Da \footnote{\url{https://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/128GPtoCreateSearchersandSolversHyperheuristics.html}}:
\begin{quote}
The difference between meta-heuristics and hyper-heuristics is that the former operate directly on the problem search space with the goal of finding optimal or near-optimal solutions. The latter, instead, operate on the heuristics search space (which consists of the heuristics used to solve the target problem). The goal then is finding or generating high-quality heuristics for a problem, for a certain class of instances of a problem, or even for a particular instance.
\end{quote}
Sempre nella stessa pagina vengono presentati diversi casi in cui GP ha ottenuto ottimi risultati come iper-euristica.

\subsection{Restrizione del problema}
\subsection{Co-evoluzione: bianco VS nero}
\subsection{Analisi e valutazione delle euristiche trovate}
%\subsection{Semplificazione e posizione relativa delle variabili}

\section{Conclusioni}

\section{Sviluppi futuri}

%===========================================================================
% bibliografia
\clearpage

% vedi: Scrivere la tesi di laurea in LATEX (IntroTesi) pag. 30 (comandi per compilazione)
\addcontentsline{toc}{chapter}{\bibname}
% complessiva (tutto):
%\printbibliography

% vedi: L’arte di scrivere con latex (ArteLaTeX) pag. 136 in avanti
% i titoli e i filtri di queste sezioni sono definiti nel preambolo
\printbibliography[heading=principali,filter=papers]
\printbibliography[heading=web,type=online]
\printbibliography[heading=integrative,type=report]

\end{document}
